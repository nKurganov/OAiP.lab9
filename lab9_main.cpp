#include "Vector.h"
#include <iostream>

using namespace std;

void print_error(int x);

int main()
{
	//контролируемый блок
	try
	{
		
		Vector x(2);//вектор из двух элементов
		Vector y;//пустой вектор
		cout << x;//печать вектора х
		cout << "Nomer?";
		int i;
		cin >> i;
		//вывод элемента с номером i, если номер больше 2 или меньше 0, то
		//генерируется исключительная ситуация
		cout << x[i] << endl;
		//добавление элемента в вектор, если MAX_SIZE=2, то генерируется
		//исключительная ситуация
		y = x + 3;
		cout << y;
		//удалить один элемент из вектора
		x = x - 1;
		cout << x;
		//удалить один элемент из вектора
		x = x - 1;
		cout << x;//вектор пустой
		//удалить один элемент из вектора
		//генерируется исключительная ситуация
		x = x - 1;
	}
	//обработчик исключения
	catch (int x)
	{
		cout << "ERROR!!!" << endl;
		print_error(x);
	}//сообщение об ошибке

	std::cin.ignore();
	std::cin.get();
	return 0;
}

void print_error(int x)
{
	switch (x) {
	case 1: std::cout << "Given size is greater than MAX_SIZE\n"; break;
	case 2: std::cout << "Index is less than 0\n"; break;
	case 3: std::cout << "Index out of range\n"; break;
	case 4: std::cout << "Can't delete values\n"; break;
	case 5: std::cout << "Size is less than given for delete\n"; break;
	}
}

//1. Что представляет собой исключение в С++ ?
//		В С++ исключение – это объект, который система должна генерировать при возникновении исключительной ситуации.
//2. На какие части исключения позволяют разделить вычислительный процесс ?
//Достоинства такого подхода ?
//		Исключения позволяют разделить вычислительный процесс на 2 части:
//		1) обнаружение аварийной ситуации(неизвестно как обрабатывать);
//		2) обработка аварийной ситуации(неизвестно, где она возникла).
//		Достоинства такого подхода :
//		1) удобно использовать в программе, которая состоит из нескольких модулей;
//		2) не требуется возвращать значение в вызывающую функцию
//3. Какой оператор используется для генерации исключительной ситуации ?
//		Исключение генерируется оператором
//		throw <выражение>, где <выражение> 
//		- либо константа, 
//		- либо переменная некоторого типа, 
//		- либо выражение некоторого типа
//4. Что представляет собой контролируемый блок ? Для чего он нужен ?
//		Контролируемый блок представляет собой секцию try {} после которого следуют секции ловушки catch{}  
//		Этот блок используется для проверки возникновения исключения.
//5. Что представляет собой секция - ловушка ? Для чего она нужна ?
//		Форма записи секции-ловушки следующая:
//		catch (спецификация исключения) 
//		Нужна для обработки возникающих ошибок 
//		
//6. Какие формы может иметь спецификация исключения в секции ловушке ? В каких
//ситуациях используются эти формы ?
//		спецификация исключения может иметь три формы :
//			1) (тип имя) - объект передается в блок обработки, чтобы его каким-то образом
//			там использовать, например, для вывода информации в сообщении об ошибке.
//			2) (тип) - блок для определённого типа ошибки.
//			3) (…) - блок для любого типа ошибки
//		Формы 1 и 2 обрабатывают конкретные исключения, а форма 3 перехватывает все
//		исключения, такую ловушку надо помещать последней, тогда она будет обрабатывать все
//		исключения, которые еще не были обработаны
//7. Какой стандартный класс можно использовать для создания собственной иерархии
//исключений ?
//		Можно определять собственные исключения, унаследовав их от класса exception.
//8. Каким образом можно создать собственную иерархию исключений ?
//		Для создания собственной иерархии исключений надо объявить свой базовый класс- исключение.
//		Остальные классы будут наследниками этого класса, аналогично тому, как это сделано в
//		иерархии стандартных исключенийНаследование от стандартных классов позволит использовать метод what для вывода
//		сообщений об ошибках. Иерархия классов - исключений позволяет вместо нескольких разных 
//		блоков - ловушек написать единственный блок с типом аргумента базового класса.
//9. Если спецификация исключений имеет вид : void f1()throw(int, double); то какие
//исключения может прождать функция f1() ?
//		исключения int и double
//10. Если спецификация исключений имеет вид : void f1()throw(); то какие исключения
//может прождать функция f1() ?
//		Никаких 
//11. В какой части программы может генерироваться исключение ?
//		В функциях и методах
//12. Написать функцию, которая вычисляет площадь треугольника по трем сторонам
//(формула Герона).
// /Функцию реализовать в 4 вариантах : 
//	- без спецификации исключений; 

//	double geron(double a, double b, double c) 
//	{
 
//		double p = (a + b + c)/2;
//		double S = (p - a) * (p - c) * (p - b);
//		return sqrt(S);
//
//	}
//	- со спецификацией throw(); 
 //double geron(double a, double b, double c) throw()
	//{
	//	double p = (a + b + c)/2;
	//	double S = (p - a) * (p - c) * (p - b);
	//	return sqrt(S);

	//}
//	- с конкретной спецификацией с подходящим стандартным исключением; 

 //double geron(double a, double b, double c) throw(invalid_argument)
	//{
	//	//треугольник имеет отрицательные или 0 стороны
	//	if (a <= 0) 
	//		throw invalid_argument("a <= 0");
	//	if (b <= 0) throw invalid_argument("b <= 0");
	//	if (c <= 0) throw invalid_argument("c <= 0");
	//	if (!(a < b + c) || !(b < a + c) || !(c < b + a)) throw  invalid_argument("triangle does not exist"); //треугольник существует
	//	double p = (a + b + c)/2;
	//	double S = (p - a) * (p - c) * (p - b);
	//	if (S <= 0) throw invalid_argument("the subordinate expression is less than 0");
	//	return sqrt(S);
	//}
//	- спецификация с собственным реализованным исключением.
// #include <stdexcept>
//class MyExcept : public invalid_argument {
//	double num;
//public:
//	MyExcept(const string msg, double n) : invalid_argument(msg), num(n) {}
//	double arg() const { return num; }
//};
//double geron(double a, double b, double c)
//{
//	//треугольник имеет отрицательные или 0 стороны
//	if (a <= 0) throw MyExcept("a <= 0", a);
//	if (b <= 0) throw MyExcept("b <= 0", b);
//	if (c <= 0) throw MyExcept("c <= 0", c);
//	//треугольник существует
//	if (!(a < b + c)) throw MyExcept("triangle does not exist", a);
//	if (!(b < a + c)) throw MyExcept("triangle does not exist", b);
//	if (!(c < b + a)) throw MyExcept("triangle does not exist", c);
//	double p = (a + b + c) / 2;
//	double S = (p - a) * (p - c) * (p - b);
//	if (S <= 0) throw MyExcept("the subordinate expression is less than 0", S);
//	return sqrt(S);
//}
////